#include "interpreter.h"
#include "../parser/nodes.h"     // Add the include for the node definitions
#include "../parser/parser.h"    // Include for Parser and Tokenizer
#include "../parser/tokenizer.h" // Include for Token
#include <iostream>
#include <sstream>
#include <fstream>
#include <memory>
#include <algorithm>
#include <cmath>
#include <set>
#include <filesystem>

// Value implementation
bool Value::asBool() const
{
    if (type == Type::Boolean)
    {
        return std::get<bool>(value);
    }
    else if (type == Type::Integer)
    {
        return std::get<int>(value) != 0;
    }
    else if (type == Type::Float)
    {
        return std::get<float>(value) != 0.0f;
    }
    else if (type == Type::String)
    {
        return !std::get<std::string>(value).empty();
    }
    else if (type == Type::Null)
    {
        return false;
    }
    return true; // Objects, functions, and classes are truthy
}

int Value::asInt() const
{
    if (type == Type::Integer)
    {
        return std::get<int>(value);
    }
    else if (type == Type::Float)
    {
        return static_cast<int>(std::get<float>(value));
    }
    else if (type == Type::Boolean)
    {
        return std::get<bool>(value) ? 1 : 0;
    }
    else if (type == Type::String)
    {
        try
        {
            return std::stoi(std::get<std::string>(value));
        }
        catch (const std::exception &)
        {
            throw std::runtime_error("Cannot convert string to integer");
        }
    }
    throw std::runtime_error("Cannot convert to integer");
}

float Value::asFloat() const
{
    if (type == Type::Float)
    {
        return std::get<float>(value);
    }
    else if (type == Type::Integer)
    {
        return static_cast<float>(std::get<int>(value));
    }
    else if (type == Type::Boolean)
    {
        return std::get<bool>(value) ? 1.0f : 0.0f;
    }
    else if (type == Type::String)
    {
        try
        {
            return std::stof(std::get<std::string>(value));
        }
        catch (const std::exception &)
        {
            throw std::runtime_error("Cannot convert string to float");
        }
    }
    throw std::runtime_error("Cannot convert to float");
}

std::string Value::asString() const
{
    if (type == Type::String)
    {
        return std::get<std::string>(value);
    }
    // Special handling for boolean to ensure "true" or "false" string instead of "1" or "0"
    if (type == Type::Boolean)
    {
        return std::get<bool>(value) ? "true" : "false";
    }
    return toString();
}

template <typename T>
std::shared_ptr<T> Value::asObject() const
{
    if (std::holds_alternative<std::shared_ptr<void>>(value))
    {
        return std::static_pointer_cast<T>(std::get<std::shared_ptr<void>>(value));
    }
    throw std::runtime_error("Value is not an object");
}

std::string Value::toString() const
{
    switch (type)
    {
    case Type::Null:
        return "null";
    case Type::Boolean:
        return std::get<bool>(value) ? "true" : "false";
    case Type::Integer:
        return std::to_string(std::get<int>(value));
    case Type::Float:
    {
        // Format float to avoid trailing zeros
        std::string result = std::to_string(std::get<float>(value));
        result.erase(result.find_last_not_of('0') + 1, std::string::npos);
        if (result.back() == '.')
            result.pop_back();
        return result;
    }
    case Type::String:
        return std::get<std::string>(value);
    case Type::Object:
        return "[object Object]";
    case Type::Function:
        return "[function]";
    case Type::Class:
        return "[class]";
    default:
        return "[unknown]";
    }
}

Value Value::operator+(const Value &other) const
{
    // Handle string concatenation
    if (type == Type::String || other.type == Type::String)
    {
        // Special handling for boolean values in string concatenation
        if (type == Type::Boolean)
        {
            std::string boolStr = std::get<bool>(value) ? "true" : "false";
            return Value(boolStr + other.toString());
        }
        else if (other.type == Type::Boolean)
        {
            std::string boolStr = other.asBool() ? "true" : "false";
            return Value(toString() + boolStr);
        }
        else
        {
            return Value(toString() + other.toString());
        }
    }

    // Handle numeric addition
    if (type == Type::Float || other.type == Type::Float)
    {
        return Value(asFloat() + other.asFloat());
    }

    return Value(asInt() + other.asInt());
}

Value Value::operator-(const Value &other) const
{
    if (type == Type::Float || other.type == Type::Float)
    {
        return Value(asFloat() - other.asFloat());
    }
    return Value(asInt() - other.asInt());
}

Value Value::operator*(const Value &other) const
{
    if (type == Type::Float || other.type == Type::Float)
    {
        return Value(asFloat() * other.asFloat());
    }
    return Value(asInt() * other.asInt());
}

Value Value::operator/(const Value &other) const
{
    if (other.asFloat() == 0.0f)
    {
        throw std::runtime_error("Division by zero");
    }

    if (type == Type::Float || other.type == Type::Float)
    {
        return Value(asFloat() / other.asFloat());
    }

    // Return float for integer division to match behavior of most languages
    return Value(static_cast<float>(asInt()) / static_cast<float>(other.asInt()));
}

Value Value::operator%(const Value &other) const
{
    if (other.asInt() == 0)
    {
        throw std::runtime_error("Modulo by zero");
    }

    return Value(asInt() % other.asInt());
}

bool Value::operator==(const Value &other) const
{
    if (type != other.type)
    {
        // Special case for numeric comparison
        if ((type == Type::Integer || type == Type::Float) &&
            (other.type == Type::Integer || other.type == Type::Float))
        {
            return asFloat() == other.asFloat();
        }
        return false;
    }

    switch (type)
    {
    case Type::Null:
        return true; // null == null
    case Type::Boolean:
        return std::get<bool>(value) == std::get<bool>(other.value);
    case Type::Integer:
        return std::get<int>(value) == std::get<int>(other.value);
    case Type::Float:
        return std::get<float>(value) == std::get<float>(other.value);
    case Type::String:
        return std::get<std::string>(value) == std::get<std::string>(other.value);
    case Type::Object:
    case Type::Function:
    case Type::Class:
        // For objects, functions, and classes, compare by reference
        return std::get<std::shared_ptr<void>>(value) == std::get<std::shared_ptr<void>>(other.value);
    default:
        return false;
    }
}

bool Value::operator!=(const Value &other) const
{
    return !(*this == other);
}

bool Value::operator<(const Value &other) const
{
    if ((type == Type::Integer || type == Type::Float) &&
        (other.type == Type::Integer || other.type == Type::Float))
    {
        return asFloat() < other.asFloat();
    }
    if (type == Type::String && other.type == Type::String)
    {
        return std::get<std::string>(value) < std::get<std::string>(other.value);
    }
    throw std::runtime_error("Cannot compare values of different types");
}

bool Value::operator>(const Value &other) const
{
    return other < *this;
}

bool Value::operator<=(const Value &other) const
{
    return *this < other || *this == other;
}

bool Value::operator>=(const Value &other) const
{
    return *this > other || *this == other;
}

// Interpreter implementation
void Interpreter::interpret(ProgramNode *program)
{
    if (!program)
    {
        throw std::runtime_error("No program to interpret");
    }

    // Set the base directory for module resolution
    baseDirectory = "./";

    globals = environment;

    try
    {
        // Phase 1: Process imports first
        // This ensures all imported functions and variables are available in the environment
        // before any other code is executed
        std::cout << "Phase 1: Processing imports first" << std::endl;
        for (const auto &node : program->children)
        {
            if (auto importNode = dynamic_cast<ImportNode *>(node.get()))
            {
                executeImportStatement(importNode);
            }
        }

        // Phase 2: Declare classes, functions and global variables
        // Now that imports are processed, we can define our own elements
        std::cout << "Phase 2: Declaring functions, classes and variables" << std::endl;
        for (const auto &node : program->children)
        {
            if (auto classNode = dynamic_cast<ClassNode *>(node.get()))
            {
                executeClass(classNode);
            }
            else if (auto funcNode = dynamic_cast<FunctionNode *>(node.get()))
            {
                executeFunction(funcNode);
            }
            else if (auto varDecl = dynamic_cast<VariableDeclarationNode *>(node.get()))
            {
                executeVariableDeclaration(varDecl);
            }
        }

        // Look for a main function and execute it if found
        lookForMainFunction(program);

        // Phase 3: Execute all statements except imports (which were already processed)
        std::cout << "Phase 3: Executing program statements" << std::endl;
        for (const auto &node : program->children)
        {
            if (!dynamic_cast<ImportNode *>(node.get())) // Skip imports since already processed
            {
                execute(node.get());
            }
        }
    }
    catch (const ReturnException &)
    {
        // Ignore return exception from global scope
    }
    catch (const std::exception &e)
    {
        std::cerr << "Runtime error: " << e.what() << std::endl;
        throw;
    }
}

// Module handling methods
std::string Interpreter::resolveModulePath(const std::string &requestedPath, const std::string &importingFile)
{
    // Simple path resolution for now
    std::string path = requestedPath;
    std::string baseDir;

    // Extract the directory part of the importing file to use as base directory
    if (!importingFile.empty())
    {
        size_t lastSlash = importingFile.find_last_of("/\\");
        if (lastSlash != std::string::npos)
        {
            baseDir = importingFile.substr(0, lastSlash + 1);
        }
    }

    // If no base directory from the importing file, use the global baseDirectory
    if (baseDir.empty())
    {
        baseDir = baseDirectory;
    }

    // Debug information for path resolution
    std::cout << "Module path resolution:" << std::endl;
    std::cout << "  Requested path: " << requestedPath << std::endl;
    std::cout << "  Importing file: " << importingFile << std::endl;
    std::cout << "  Base dir: " << baseDir << std::endl;

    // If it starts with ./ or ../, it's a relative path
    if (path.find("./") == 0)
    {
        path = baseDir + path.substr(2); // Remove the ./
    }
    else if (path.find("../") == 0)
    {
        // Handle parent directory references
        std::string parentDir = baseDir;
        if (!parentDir.empty() && parentDir.back() == '/')
        {
            parentDir.pop_back(); // Remove trailing slash
        }

        size_t lastSlash = parentDir.find_last_of("/\\");
        if (lastSlash != std::string::npos)
        {
            parentDir = parentDir.substr(0, lastSlash + 1);
            path = parentDir + path.substr(3); // Remove the ../
        }
    }

    // Add .edu extension if it doesn't have one
    if (path.find(".edu") == std::string::npos)
    {
        path += ".edu";
    }

    DEBUG_LOG("Resolved module path: ", path);
    return path;
}

std::shared_ptr<Module> Interpreter::loadModule(const std::string &modulePath)
{
    // Check if module is already loaded
    auto it = loadedModules.find(modulePath);
    if (it != loadedModules.end())
    {
        std::cout << "Using cached module for: " << modulePath << std::endl;

        // Examine the cached module's exports for debugging
        std::cout << "Cached module exports information:" << std::endl;
        std::cout << "  Named exports: " << it->second->namedExports.size() << std::endl;
        for (const auto &[name, val] : it->second->namedExports)
        {
            std::cout << "    - " << name << " (type: " << static_cast<int>(val.getType()) << ")" << std::endl;
        }

        return it->second;
    }

    std::cout << "Loading new module from path: " << modulePath << std::endl;

    // Create a new module
    auto module = std::make_shared<Module>(modulePath);

    // Store the module in the cache before parsing to handle circular dependencies
    loadedModules[modulePath] = module;

    try
    {
        // 1. Read the file from the filesystem
        std::ifstream file(modulePath);
        if (!file.is_open())
        {
            throw std::runtime_error("Could not open module file: " + modulePath);
        }

        DEBUG_LOG("Successfully opened module file: ", modulePath);

        std::stringstream buffer;
        buffer << file.rdbuf();
        std::string content = buffer.str();
        file.close();

        // 2. Parse the file into an AST
        Tokenizer tokenizer(content);
        std::vector<Token> tokens = tokenizer.tokenize();
        Parser parser(tokens);
        std::unique_ptr<ProgramNode> program = parser.parse();

        if (!program)
        {
            throw std::runtime_error("Failed to parse module: " + modulePath);
        }

        // 3. Execute the module code with a dedicated module environment
        std::shared_ptr<Environment> previousEnv = environment;

        // Create a new environment for the module with globals as parent
        std::shared_ptr<Environment> moduleEnv = std::make_shared<Environment>(globals);

        // Set the module environment as current
        environment = moduleEnv;

        // Store the environment in the module for later reference
        module->exports = moduleEnv;

        try
        {
            // First pass to collect declarations
            for (const auto &node : program->children)
            {
                if (auto exportNode = dynamic_cast<ExportNode *>(node.get()))
                {
                    // Record export items
                    collectExport(exportNode, module);
                }
                else if (auto reExportNode = dynamic_cast<ReExportNode *>(node.get()))
                {
                    // Handle re-exports
                    executeReExportStatement(reExportNode, module);
                }
                else if (auto funcNode = dynamic_cast<FunctionNode *>(node.get()))
                {
                    // Pre-declare functions
                    executeFunction(funcNode);

                    // For functions, make sure they're available in the global scope
                    try
                    {
                        Value funcValue = environment->get(funcNode->name);
                        globals->define(funcNode->name, funcValue);
                        std::cout << "Registered function " << funcNode->name << " globally" << std::endl;
                    }
                    catch (const std::exception &)
                    {
                        // Ignore errors
                    }
                }
                else if (auto classNode = dynamic_cast<ClassNode *>(node.get()))
                {
                    // Pre-declare classes
                    executeClass(classNode);
                }
            }
            // Second pass to execute statements
            for (const auto &node : program->children)
            {
                execute(node.get());
            }
        }
        catch (const std::exception &e)
        {
            environment = previousEnv;
            throw std::runtime_error("Error executing module " + modulePath + ": " + e.what());
        }

        // Restore previous environment
        environment = previousEnv;
    }
    catch (const std::exception &e)
    {
        loadedModules.erase(modulePath); // Remove the module from cache on error
        throw;                           // Re-throw the exception
    }

    return module;
}

void Interpreter::collectExport(ExportNode *node, std::shared_ptr<Module> module)
{
    if (!module)
    {
        throw std::runtime_error("Cannot export: module is null");
    }

    if (!node->exportItem)
    {
        return;
    }

    // For function exports, we need special handling
    if (auto *funcNode = dynamic_cast<FunctionNode *>(node->exportItem.get()))
    {
        // Define the function first in the environment (if not already defined)
        if (!environment->contains(funcNode->name))
        {
            executeFunction(funcNode);
        }

        try
        {
            // Get the function from current environment
            Value funcValue = environment->get(funcNode->name);

            // Add to module's exports directly with the original name
            module->namedExports[funcNode->name] = funcValue;
            std::cout << "Added function " << funcNode->name << " to module exports" << std::endl;
        }
        catch (const std::exception &e)
        {
            std::cout << "ERROR: Failed to register function: " << e.what() << std::endl;
        }
    }
    else
    {
        // For other export types, execute normally
        execute(node->exportItem.get());
    }

    if (node->isDefault)
    {
        // Handle default export
        if (auto *funcNode = dynamic_cast<FunctionNode *>(node->exportItem.get()))
        {
            // Get the function from environment
            module->defaultExport = environment->get(funcNode->name);
            module->hasDefault = true;
            DEBUG_LOG("Exported default function: ", funcNode->name);
        }
        else if (auto *varNode = dynamic_cast<VariableDeclarationNode *>(node->exportItem.get()))
        {
            // Get the variable from environment
            module->defaultExport = environment->get(varNode->name);
            module->hasDefault = true;
            DEBUG_LOG("Exported default variable: ", varNode->name);
        }
        else if (auto *exprNode = dynamic_cast<ExpressionNode *>(node->exportItem.get()))
        {
            // Evaluate the expression and use its value as default export
            Value value = evaluate(exprNode);
            module->defaultExport = value;
            module->hasDefault = true;
            DEBUG_LOG("Exported default expression result");
        }
    }
    else
    {
        // Handle named export
        if (auto *funcNode = dynamic_cast<FunctionNode *>(node->exportItem.get()))
        {
            // Get the function from environment
            Value funcValue = environment->get(funcNode->name);

            // Add to namedExports only if not already present
            if (module->namedExports.find(funcNode->name) == module->namedExports.end())
            {
                module->namedExports[funcNode->name] = funcValue;
                module->exports->define(funcNode->name, funcValue);
            }
        }
        else if (auto *varNode = dynamic_cast<VariableDeclarationNode *>(node->exportItem.get()))
        {
            // Get the variable from environment
            Value varValue = environment->get(varNode->name);

            // Add to namedExports
            if (module->namedExports.find(varNode->name) == module->namedExports.end())
            {
                module->namedExports[varNode->name] = varValue;
                module->exports->define(varNode->name, varValue);
            }
        }
    }
}

void Interpreter::executeReExportStatement(ReExportNode *node, std::shared_ptr<Module> module)
{
    if (!module)
    {
        throw std::runtime_error("Cannot re-export: module is null");
    }

    // Load the referenced module
    std::string resolvedPath = resolveModulePath(node->moduleName, module->path);
    auto sourceModule = loadModule(resolvedPath);

    if (node->exportAll)
    {
        // Re-export everything from the source module
        for (const auto &[name, value] : sourceModule->namedExports)
        {
            module->namedExports[name] = value;
            DEBUG_LOG("Re-exported: ", name);
        }

        if (sourceModule->hasDefault)
        {
            // Optionally re-export the default as well
            module->defaultExport = sourceModule->defaultExport;
            module->hasDefault = true;
            DEBUG_LOG("Re-exported default export");
        }
    }
    else
    {
        // Re-export specific items
        for (const auto &[sourceName, exportName] : node->namedExports)
        {
            if (sourceName == "default" && sourceModule->hasDefault)
            {
                // Handle "export { default as xyz } from './module'"
                module->namedExports[exportName] = sourceModule->defaultExport;
                DEBUG_LOG("Re-exported default as: ", exportName);
            }
            else
            {
                auto it = sourceModule->namedExports.find(sourceName);
                if (it != sourceModule->namedExports.end())
                {
                    module->namedExports[exportName] = it->second;
                    DEBUG_LOG("Re-exported: ", sourceName, " as ", exportName);
                }
                else
                {
                    throw std::runtime_error("Cannot re-export '" + sourceName + "': not found in module");
                }
            }
        }
    }
}

void Interpreter::executeImportStatement(ImportNode *node)
{
    std::cout << "Processing import from module: " << node->moduleName << std::endl;

    // Resolve the module path
    std::string resolvedPath = resolveModulePath(node->moduleName, "");
    std::cout << "Importing module: " << node->moduleName << " from " << resolvedPath << std::endl;

    // Load the module
    auto module = loadModule(resolvedPath);

    if (!module)
    {
        std::cout << "Failed to load module: " << resolvedPath << std::endl;
        throw std::runtime_error("Failed to load module: " + resolvedPath);
    }

    // Handle default import if present
    if (node->hasDefaultImport && module->hasDefault)
    {
        environment->define(node->defaultImportName, module->defaultExport);
        std::cout << "Imported default as: " << node->defaultImportName << std::endl;
    }

    std::cout << "Module named exports count: " << module->namedExports.size() << std::endl;

    // Handle named imports
    for (const auto &[originalName, localName] : node->namedImports)
    {
        std::cout << "Processing import of named export: " << originalName << " as " << localName << std::endl;
        auto it = module->namedExports.find(originalName);
        if (it != module->namedExports.end())
        {
            // Get the imported value
            Value importedValue = it->second;
            std::cout << "  Found export value of type: " << static_cast<int>(importedValue.getType()) << std::endl;
            // Handle functions specially
            if (importedValue.isFunction())
            {
                try
                {
                    // Get the function object
                    auto funcObj = importedValue.asObject<Function>();

                    if (funcObj)
                    {
                        // SIMPLEST APPROACH: Just use the same function but update its environment
                        funcObj->closure = environment;

                        if (funcObj->declaration && funcObj->declaration->body)
                        {
                            std::cout << "Function body found with " << funcObj->declaration->body->statements.size() << " statements" << std::endl;
                            std::cout << "MODULE FIX: Defining function " << localName << " in environment" << std::endl;
                        }

                        // We're using the same function object, no need to update importedValue
                    }
                }
                catch (const std::exception &e)
                {
                    std::cerr << "Error processing imported function: " << e.what() << std::endl;
                    throw;
                }
            }

            // Register in environment
            environment->define(localName, importedValue);

            // Also register in global environment
            globals->define(localName, importedValue);

            // Make sure the original name is registered if it's different
            if (originalName != localName)
            {
                environment->define(originalName, importedValue);
                globals->define(originalName, importedValue);
            }

            std::cout << "Registered import " << originalName << " as " << localName << std::endl;
        }
        else
        {
            throw std::runtime_error("Named export not found: " + originalName);
        }
    }
}

void Interpreter::lookForMainFunction(ProgramNode *program)
{
    // Look for a function named "main"
    for (const auto &node : program->children)
    {
        if (auto funcNode = dynamic_cast<FunctionNode *>(node.get()))
        {
            if (funcNode->name == "main")
            {
                DEBUG_LOG("Found main function, executing it");

                // Get the function from the environment
                auto mainFunc = environment->get("main");
                if (mainFunc.isFunction())
                {
                    // Call the main function with no arguments
                    std::vector<Value> args;
                    callFunction(mainFunc.asObject<Function>(), args);

                    // Stop further processing
                    throw ReturnException(Value());
                }
            }
        }
    }
}

void Interpreter::execute(ASTNode *node)
{
    if (!node)
        return;

    DEBUG_LOG("Executing node type: ", typeid(*node).name());

    if (auto blockNode = dynamic_cast<BlockStatementNode *>(node))
    {
        executeBlockStatement(blockNode);
    }
    else if (auto varDeclNode = dynamic_cast<VariableDeclarationNode *>(node))
    {
        executeVariableDeclaration(varDeclNode);
    }
    else if (auto ifNode = dynamic_cast<IfStatementNode *>(node))
    {
        executeIfStatement(ifNode);
    }
    else if (auto whileNode = dynamic_cast<WhileStatementNode *>(node))
    {
        executeWhileStatement(whileNode);
    }
    else if (auto forNode = dynamic_cast<ForStatementNode *>(node))
    {
        executeForStatement(forNode);
    }
    else if (auto switchNode = dynamic_cast<SwitchStatementNode *>(node))
    {
        executeSwitchStatement(switchNode);
    }
    else if (auto breakNode = dynamic_cast<BreakStatementNode *>(node))
    {
        executeBreakStatement(breakNode);
    }
    else if (auto returnNode = dynamic_cast<ReturnStatementNode *>(node))
    {
        executeReturnStatement(returnNode);
    }
    else if (auto exprStmtNode = dynamic_cast<ExpressionStatementNode *>(node))
    {
        executeExpressionStatement(exprStmtNode);
    }
    else if (auto consoleLogNode = dynamic_cast<ConsoleLogNode *>(node))
    {
        executeConsoleLog(consoleLogNode);
    }
    else if (auto inputNode = dynamic_cast<InputStatementNode *>(node))
    {
        executeInputStatement(inputNode);
    }
    else if (auto functionNode = dynamic_cast<FunctionNode *>(node))
    {
        executeFunction(functionNode);
    }
    else if (auto classNode = dynamic_cast<ClassNode *>(node))
    {
        executeClass(classNode);
    }
    else if (auto importNode = dynamic_cast<ImportNode *>(node))
    {
        executeImportStatement(importNode);
    }
    else if (auto exportNode = dynamic_cast<ExportNode *>(node))
    {
        // For now, we'll just execute the exported item
        if (exportNode->exportItem)
        {
            execute(exportNode->exportItem.get());
        }
        // We would also register this in a proper module system
    }
    else if (dynamic_cast<ReExportNode *>(node))
    {
        // Handle re-export statements
        std::cout << "Re-export statement encountered (not fully implemented)" << std::endl;
    }
    else
    {
        DEBUG_LOG("Unhandled node type: ", typeid(*node).name());
    }
}

Value Interpreter::evaluate(ExpressionNode *expr)
{
    if (!expr)
        return Value(); // Return null for null expressions

    DEBUG_LOG("Evaluating expression type: ", typeid(*expr).name());

    if (auto varExpr = dynamic_cast<VariableExpressionNode *>(expr))
    {
        return evaluateVariableExpression(varExpr);
    }
    else if (auto callExpr = dynamic_cast<CallExpressionNode *>(expr))
    {
        return evaluateCallExpression(callExpr);
    }
    else if (auto assignExpr = dynamic_cast<AssignmentExpressionNode *>(expr))
    {
        return evaluateAssignmentExpression(assignExpr);
    }
    else if (auto memberAccessExpr = dynamic_cast<MemberAccessExpressionNode *>(expr))
    {
        return evaluateMemberAccessExpression(memberAccessExpr);
    }
    else if (auto intLiteral = dynamic_cast<IntegerLiteralNode *>(expr))
    {
        return evaluateIntegerLiteral(intLiteral);
    }
    else if (auto floatLiteral = dynamic_cast<FloatingPointLiteralNode *>(expr))
    {
        return evaluateFloatingPointLiteral(floatLiteral);
    }
    else if (auto stringLiteral = dynamic_cast<StringLiteralNode *>(expr))
    {
        return evaluateStringLiteral(stringLiteral);
    }
    else if (auto boolLiteral = dynamic_cast<BooleanLiteralNode *>(expr))
    {
        return evaluateBooleanLiteral(boolLiteral);
    }
    else if (auto nullLiteral = dynamic_cast<NullLiteralNode *>(expr))
    {
        return evaluateNullLiteral(nullLiteral);
    }
    else if (auto addExpr = dynamic_cast<AdditionExpressionNode *>(expr))
    {
        Value left = evaluate(addExpr->left.get());
        Value right = evaluate(addExpr->right.get());
        return left + right;
    }
    else if (auto subExpr = dynamic_cast<SubtractionExpressionNode *>(expr))
    {
        Value left = evaluate(subExpr->left.get());
        Value right = evaluate(subExpr->right.get());
        return left - right;
    }
    else if (auto mulExpr = dynamic_cast<MultiplicationExpressionNode *>(expr))
    {
        Value left = evaluate(mulExpr->left.get());
        Value right = evaluate(mulExpr->right.get());
        return left * right;
    }
    else if (auto divExpr = dynamic_cast<DivisionExpressionNode *>(expr))
    {
        Value left = evaluate(divExpr->left.get());
        Value right = evaluate(divExpr->right.get());
        return left / right;
    }
    else if (auto compExpr = dynamic_cast<ComparisonExpressionNode *>(expr))
    {
        Value left = evaluate(compExpr->left.get());
        Value right = evaluate(compExpr->right.get());

        if (compExpr->op == "<")
            return Value(left < right);
        if (compExpr->op == ">")
            return Value(left > right);
        if (compExpr->op == "<=")
            return Value(left <= right);
        if (compExpr->op == ">=")
            return Value(left >= right);

        throw std::runtime_error("Unknown comparison operator: " + compExpr->op);
    }
    else if (auto eqExpr = dynamic_cast<EqualityExpressionNode *>(expr))
    {
        Value left = evaluate(eqExpr->left.get());
        Value right = evaluate(eqExpr->right.get());

        if (eqExpr->op == "==")
            return Value(left == right);
        if (eqExpr->op == "!=")
            return Value(left != right);

        throw std::runtime_error("Unknown equality operator: " + eqExpr->op);
    }
    else if (auto orExpr = dynamic_cast<OrExpressionNode *>(expr))
    {
        Value left = evaluate(orExpr->left.get());

        // Short-circuit evaluation
        if (left.asBool())
            return Value(true);

        Value right = evaluate(orExpr->right.get());
        return Value(right.asBool());
    }
    else if (auto andExpr = dynamic_cast<AndExpressionNode *>(expr))
    {
        Value left = evaluate(andExpr->left.get());

        // Short-circuit evaluation
        if (!left.asBool())
            return Value(false);

        Value right = evaluate(andExpr->right.get());
        return Value(right.asBool());
    }
    else if (auto binaryExpr = dynamic_cast<BinaryExpressionNode *>(expr))
    {
        return evaluateBinaryExpression(binaryExpr);
    }

    DEBUG_LOG("Unknown expression type: ", typeid(*expr).name());
    return Value(); // Default to null
}

void Interpreter::executeBlockStatement(BlockStatementNode *node, std::shared_ptr<Environment> env)
{
    std::shared_ptr<Environment> previous = this->environment;

    try
    {
        if (env)
        {
            // If an environment is provided, use it
            this->environment = env;
        }
        else
        {
            // Otherwise, create a new environment with the current one as enclosing
            this->environment = std::make_shared<Environment>(this->environment);
        }

        for (const auto &statement : node->statements)
        {
            execute(statement.get());
        }
    }
    catch (const ReturnException &)
    {
        // Let the return exception propagate up
        this->environment = previous;
        throw;
    }
    catch (const std::exception &e)
    {
        this->environment = previous;
        throw;
    }

    this->environment = previous;
}

void Interpreter::executeVariableDeclaration(VariableDeclarationNode *node)
{
    Value initialValue;

    if (node->initializer)
    {
        // First, check if the typeName corresponds to a class in the environment
        bool isClassType = false;
        try
        {
            Value classValue = environment->get(node->typeName);
            isClassType = classValue.isClass();
        }
        catch (...)
        {
            // Class doesn't exist in environment, continue with normal processing
        }

        // Special handling for class instantiation
        if (isClassType)
        {
            if (auto callExpr = dynamic_cast<CallExpressionNode *>(node->initializer.get()))
            {
                if (auto varExpr = dynamic_cast<VariableExpressionNode *>(callExpr->callee.get()))
                {
                    if (varExpr->name == node->typeName)
                    {
                        // This is definitely a class instantiation: TypeName var = TypeName();
                        DEBUG_LOG("Detected class instantiation: ", node->typeName, " ", node->name);

                        // Get the class from environment
                        Value classValue = environment->get(node->typeName);
                        auto klass = classValue.asObject<Class>();

                        // Create arguments for constructor
                        std::vector<Value> arguments;
                        for (const auto &arg : callExpr->arguments)
                        {
                            arguments.push_back(evaluate(arg.get()));
                        }

                        // Create the instance
                        initialValue = createInstance(klass, arguments);
                        DEBUG_LOG("Created instance successfully, type: ", static_cast<int>(initialValue.getType()));
                    }
                    else
                    {
                        // Different function call, evaluate normally
                        initialValue = evaluate(node->initializer.get());
                    }
                }
                else
                {
                    // Complex call expression, evaluate normally
                    initialValue = evaluate(node->initializer.get());
                }
            }
            else
            {
                // Not a call expression, evaluate normally
                initialValue = evaluate(node->initializer.get());
            }
        }
        else
        {
            // Not a class type, evaluate normally
            initialValue = evaluate(node->initializer.get());
        }

        // Log the type of initial value for debugging
        DEBUG_LOG("Initial value for ", node->name, " type: ", static_cast<int>(initialValue.getType()),
                  " is object: ", initialValue.isObject());
    }
    else
    {
        // Default values based on type
        if (node->typeName == "int")
            initialValue = Value(0);
        else if (node->typeName == "float")
            initialValue = Value(0.0f);
        else if (node->typeName == "string")
            initialValue = Value(std::string(""));
        else if (node->typeName == "bool")
            initialValue = Value(false);
        // Default to null for other types (including classes without initializers)
    }

    environment->define(node->name, initialValue);
    DEBUG_LOG("Defined variable ", node->name, " type: ", static_cast<int>(initialValue.getType()),
              " value: ", initialValue.toString(), " is object: ", initialValue.isObject());
}
void Interpreter::executeIfStatement(IfStatementNode *node)
{
    Value condition = evaluate(node->condition.get());

    if (condition.asBool())
    {
        execute(node->thenBranch.get());
    }
    else if (node->elseBranch)
    {
        execute(node->elseBranch.get());
    }
}

void Interpreter::executeWhileStatement(WhileStatementNode *node)
{
    try
    {
        while (evaluate(node->condition.get()).asBool())
        {
            try
            {
                execute(node->body.get());
            }
            catch (BreakException &)
            {
                // Break out of the loop
                break;
            }
        }
    }
    catch (ReturnException &)
    {
        // Let return propagate up
        throw;
    }
}

void Interpreter::executeForStatement(ForStatementNode *node)
{
    // Create a new environment for the for loop
    std::shared_ptr<Environment> previous = this->environment;
    this->environment = std::make_shared<Environment>(this->environment);

    try
    {
        // Execute initializer once
        if (node->initializer)
        {
            execute(node->initializer.get());
        }

        // Execute condition, body, and increment in a loop
        while (!node->condition || evaluate(node->condition.get()).asBool())
        {
            try
            {
                // Execute the loop body
                if (node->body)
                {
                    execute(node->body.get());
                }
            }
            catch (BreakException &)
            {
                // Break out of the loop
                break;
            }

            // Execute the increment expression
            if (node->increment)
            {
                evaluate(node->increment.get());
            }

            // If no condition is provided, break after one iteration (do-once loop)
            if (!node->condition)
            {
                break;
            }
        }
    }
    catch (ReturnException &)
    {
        // Let return propagate up
        this->environment = previous;
        throw;
    }
    catch (const std::exception &e)
    {
        // Handle other exceptions and restore environment
        this->environment = previous;
        throw std::runtime_error(std::string("Error in for statement: ") + e.what());
    }

    // Restore the previous environment
    this->environment = previous;
}

void Interpreter::executeSwitchStatement(SwitchStatementNode *node)
{
    if (!node || !node->condition)
    {
        throw std::runtime_error("Invalid switch statement");
    }

    // Evaluate the switch expression
    Value switchValue = evaluate(node->condition.get());

    bool matchFound = false;
    bool fallThrough = false;

    try
    {
        // Iterate through all case clauses
        for (const auto &caseClause : node->cases)
        {
            if (!caseClause)
                continue;

            // Check if this is a default case or if we found a match
            if (caseClause->isDefault || fallThrough)
            {
                matchFound = true;
            }
            else if (caseClause->caseExpression)
            {
                // Evaluate the case expression
                Value caseValue = evaluate(caseClause->caseExpression.get());

                // Check if the values match
                if (switchValue == caseValue)
                {
                    matchFound = true;
                }
            }

            // If we found a match, execute the statements in this case
            if (matchFound)
            {
                try
                {
                    for (const auto &statement : caseClause->statements)
                    {
                        execute(statement.get());
                    }

                    // Continue to next case (fall-through behavior)
                    fallThrough = true;
                }
                catch (BreakException &)
                {
                    // Break encountered, exit the switch
                    return;
                }
            }
        }
    }
    catch (ReturnException &)
    {
        // Let return exceptions propagate up
        throw;
    }
    catch (const std::exception &e)
    {
        throw std::runtime_error("Error in switch statement: " + std::string(e.what()));
    }
}

void Interpreter::executeBreakStatement(BreakStatementNode *node)
{
    // Simply throw a BreakException to be caught by the enclosing loop or switch
    throw BreakException();
}

void Interpreter::executeReturnStatement(ReturnStatementNode *node)
{
    Value returnValue;

    if (node->expression)
    {
        returnValue = evaluate(node->expression.get());
    }

    throw ReturnException(returnValue);
}

void Interpreter::executeExpressionStatement(ExpressionStatementNode *node)
{
    lastValue = evaluate(node->expression.get());
}

void Interpreter::executeConsoleLog(ConsoleLogNode *node)
{
    if (!node || !node->expression)
    {
        std::cout << std::endl;
        return;
    }

    Value value = evaluate(node->expression.get());

    // For boolean values, explicitly convert to "true" or "false" strings
    if (value.getType() == Value::Type::Boolean)
    {
        std::cout << (value.asBool() ? "true" : "false") << std::endl;
    }
    else
    {
        std::cout << value.toString() << std::endl;
    }
}

void Interpreter::executeInputStatement(InputStatementNode *node)
{
    std::string input;
    std::getline(std::cin, input);

    if (node->variable)
    {
        Value inputValue = Value(input);
        // Convert based on variable type if needed
        if (node->variable->typeName == "int")
        {
            try
            {
                inputValue = Value(std::stoi(input));
            }
            catch (...)
            {
                inputValue = Value(0);
            }
        }
        else if (node->variable->typeName == "float")
        {
            try
            {
                inputValue = Value(std::stof(input));
            }
            catch (...)
            {
                inputValue = Value(0.0f);
            }
        }
        else if (node->variable->typeName == "bool")
        {
            if (input == "true" || input == "1")
            {
                inputValue = Value(true);
            }
            else
            {
                inputValue = Value(false);
            }
        }

        environment->define(node->variable->name, inputValue);
    }
}

void Interpreter::executeFunction(FunctionNode *node)
{
    // CRITICAL FIX FOR MODULE IMPORTS: Create function with stronger reference preservation
    std::cout << "Creating function: " << node->name << std::endl;

    // Create a shared_ptr to the node with a no-op deleter to avoid double-free
    auto nodeCopy = std::static_pointer_cast<FunctionNode>(
        std::shared_ptr<ASTNode>((ASTNode *)node, [](ASTNode *) {}));

    // Create function with current environment as closure
    auto function = std::make_shared<Function>(nodeCopy, environment);

    // Note: Function already preserves declaration through constructor parameter

    // Create function value
    Value functionValue = Value(std::static_pointer_cast<void>(function), Value::Type::Function);

    // Add the function to the environment
    environment->define(node->name, functionValue);

    // Debug information
    std::cout << "Function defined: " << node->name << " with declaration preserved" << std::endl;
    DEBUG_LOG("Defined function: ", node->name);
}

void Interpreter::executeClass(ClassNode *node)
{
    std::cout << "DEBUG: Executing class declaration for: " << node->name << std::endl;

    // Create a new class
    auto klass = std::make_shared<Class>(node->name);

    // Handle inheritance by setting up parent class relationship
    if (!node->baseClassName.empty())
    {
        try
        {
            // Look up the parent class in the environment
            Value parentClassValue = environment->get(node->baseClassName);

            // Verify that it is a class
            if (parentClassValue.isClass())
            {
                // Set the parent class reference
                klass->parentClass = parentClassValue.asObject<Class>();
                std::cout << "Class " << node->name << " extends " << node->baseClassName << std::endl;

                // Copy parent class field names
                if (klass->parentClass)
                {
                    klass->fieldNames = klass->parentClass->fieldNames;
                }
            }
            else
            {
                throw std::runtime_error("Base class '" + node->baseClassName + "' is not a class");
            }
        }
        catch (const std::exception &e)
        {
            throw std::runtime_error("Cannot find base class '" + node->baseClassName + "': " + e.what());
        }
    }

    // Define methods, collect field names, and look for constructor
    for (const auto &member : node->members)
    {
        if (auto method = dynamic_cast<FunctionNode *>(member.get()))
        {
            auto function = std::make_shared<Function>(
                std::static_pointer_cast<FunctionNode>(
                    std::shared_ptr<ASTNode>((ASTNode *)method, [](ASTNode *) {})));

            // Check if this is a constructor
            if (method->name == "constructor")
            {
                klass->constructor = function;
                std::cout << "Found constructor for class " << node->name << std::endl;
            }
            else
            {
                klass->methods[method->name] = function;
                std::cout << "Added method " << method->name << " to class " << node->name << std::endl;
            }
        }
        // Collect field names from variable declarations
        else if (auto varDecl = dynamic_cast<VariableDeclarationNode *>(member.get()))
        {
            klass->fieldNames.push_back(varDecl->name);
            DEBUG_LOG("Added field ", varDecl->name, " to class ", node->name);
        }
        // Support property declarations as well
        else if (auto propDecl = dynamic_cast<PropertyDeclarationNode *>(member.get()))
        {
            klass->fieldNames.push_back(propDecl->name);
            DEBUG_LOG("Added property ", propDecl->name, " to class ", node->name);
        }
    }

    // If this class has a parent but no constructor, create a default constructor
    // that calls the parent constructor
    if (klass->parentClass && !klass->constructor)
    {
        // TODO: Implement default constructor that calls parent constructor
    }

    // Add the class to the environment
    environment->define(node->name, Value(std::static_pointer_cast<void>(klass), Value::Type::Class));
    DEBUG_LOG("Defined class: ", node->name);
}

Value Interpreter::evaluateVariableExpression(VariableExpressionNode *node)
{
    DEBUG_LOG("=== EVALUATING VARIABLE: ", node->name, " ===");

    try
    {
        Value result = environment->get(node->name);
        DEBUG_LOG("Variable '", node->name, "' found with type: ", static_cast<int>(result.getType()),
                  ", isObject: ", result.isObject(),
                  ", value: ", result.toString());
        return result;
    }
    catch (const std::exception &e)
    {
        DEBUG_LOG("ERROR: Variable '", node->name, "' not found: ", e.what());
        throw;
    }
}

Value Interpreter::evaluateBinaryExpression(BinaryExpressionNode *node)
{
    DEBUG_LOG("Evaluating binary expression with operator: ", node->op);

    if (node->op == "+")
    {
        // For addition, evaluate in standard left-to-right order
        Value left = evaluate(node->left.get());
        Value right = evaluate(node->right.get());

        DEBUG_LOG("Left operand type: ", static_cast<int>(left.getType()));
        DEBUG_LOG("Right operand type: ", static_cast<int>(right.getType()));

        // If either operand is a string, handle as string concatenation
        if (left.getType() == Value::Type::String || right.getType() == Value::Type::String)
        {
            // Special handling for boolean values in concatenation
            if (left.getType() == Value::Type::Boolean)
            {
                std::string boolStr = left.asBool() ? "true" : "false";
                return Value(boolStr + right.toString());
            }
            else if (right.getType() == Value::Type::Boolean)
            {
                std::string boolStr = right.asBool() ? "true" : "false";
                return Value(left.toString() + boolStr);
            }

            // Regular string concatenation
            return Value(left.toString() + right.toString());
        }

        // Regular numeric addition
        return left + right;
    }

    // For other operators, use standard evaluation order
    Value left = evaluate(node->left.get());
    Value right = evaluate(node->right.get());

    if (node->op == "-")
        return left - right;
    if (node->op == "*")
        return left * right;
    if (node->op == "/")
        return left / right;
    if (node->op == "%")
    {
        int leftInt = left.asInt();
        int rightInt = right.asInt();

        if (rightInt == 0)
            throw std::runtime_error("Modulo by zero");

        return Value(leftInt % rightInt);
    }

    throw std::runtime_error("Unknown binary operator: " + node->op);
}

Value Interpreter::evaluateCallExpression(CallExpressionNode *node)
{
    DEBUG_LOG("=== EVALUATING CALL EXPRESSION ===");

    // Check if this is a method call (object.method())
    if (auto memberExpr = dynamic_cast<MemberAccessExpressionNode *>(node->callee.get()))
    {
        DEBUG_LOG("METHOD CALL DETECTED");
        DEBUG_LOG("Method name: ", memberExpr->memberName);

        // Debug the object expression before evaluating
        if (auto varExpr = dynamic_cast<VariableExpressionNode *>(memberExpr->object.get()))
        {
            DEBUG_LOG("Object is a variable: ", varExpr->name);
        }
        else
        {
            DEBUG_LOG("Object is not a simple variable");
        }

        // First evaluate the object
        DEBUG_LOG("About to evaluate object...");
        Value object = evaluate(memberExpr->object.get());
        DEBUG_LOG("Evaluated object type: ", static_cast<int>(object.getType()),
                  ", isObject: ", object.isObject(),
                  ", value: ", object.toString());

        if (object.isObject())
        {
            auto obj = object.asObject<Object>();
            if (obj && obj->klass)
            {
                DEBUG_LOG("Object has class: ", obj->klass->name);

                // Check if the class has the method
                if (obj->klass->hasMethod(memberExpr->memberName))
                {
                    DEBUG_LOG("Method found in class");

                    // Get the method and bind it to the object
                    auto method = obj->klass->getMethod(memberExpr->memberName);
                    auto boundMethod = std::make_shared<Function>(
                        method->declaration,
                        method->closure, // Preserve the original closure
                        std::static_pointer_cast<void>(obj));

                    // Prepare arguments
                    std::vector<Value> arguments;
                    for (const auto &arg : node->arguments)
                    {
                        arguments.push_back(evaluate(arg.get()));
                    }

                    // Call the method
                    DEBUG_LOG("Calling method with ", arguments.size(), " arguments");
                    return callFunction(boundMethod, arguments);
                }
                else
                {
                    throw std::runtime_error("Method '" + memberExpr->memberName +
                                             "' not found in class '" + obj->klass->name + "'");
                }
            }
            else
            {
                DEBUG_LOG("Object has no class");
                throw std::runtime_error("Object has no class");
            }
        }
        else
        {
            // Error case - trying to call a method on a non-object
            std::string typeName;
            switch (object.getType())
            {
            case Value::Type::Null:
                typeName = "null";
                break;
            case Value::Type::Boolean:
                typeName = "boolean";
                break;
            case Value::Type::Integer:
                typeName = "integer";
                break;
            case Value::Type::Float:
                typeName = "float";
                break;
            case Value::Type::String:
                typeName = "string";
                break;
            case Value::Type::Object:
                typeName = "object";
                break;
            case Value::Type::Function:
                typeName = "function";
                break;
            case Value::Type::Class:
                typeName = "class";
                break;
            default:
                typeName = "unknown";
                break;
            }

            DEBUG_LOG("ERROR: Object evaluated to non-object type: ", typeName);
            throw std::runtime_error("Cannot access property '" + memberExpr->memberName +
                                     "' of non-object value (type: " + typeName + ")");
        }
    }

    // Regular function call path
    DEBUG_LOG("REGULAR FUNCTION CALL");

    // First evaluate the callee
    Value callee = evaluate(node->callee.get());

    // Debug the callee type
    if (auto varExpr = dynamic_cast<VariableExpressionNode *>(node->callee.get()))
    {
        DEBUG_LOG("Calling function: ", varExpr->name);
    }

    // Prepare arguments
    std::vector<Value> arguments;
    for (const auto &arg : node->arguments)
    {
        DEBUG_LOG("Evaluating argument...");
        arguments.push_back(evaluate(arg.get()));
    }
    DEBUG_LOG("Call with ", arguments.size(), " arguments");

    // Handle different callee types
    if (callee.isFunction())
    {
        // Regular function call
        DEBUG_LOG("Calling a function");
        return callFunction(callee.asObject<Function>(), arguments);
    }
    else if (callee.isClass())
    {
        // Class instantiation - "new" operator simulation
        auto klass = callee.asObject<Class>();
        DEBUG_LOG("Instantiating class: ", klass->name);

        Value instance = createInstance(klass, arguments);
        DEBUG_LOG("Instance created, type: ", static_cast<int>(instance.getType()));
        return instance;
    }
    else if (callee.getType() == Value::Type::Object && std::holds_alternative<std::shared_ptr<void>>(callee.getValue()))
    {
        // Check if it's a native function wrapper
        try
        {
            auto nativeFunc = std::static_pointer_cast<NativeFunctionWrapper>(std::get<std::shared_ptr<void>>(callee.getValue()));
            DEBUG_LOG("Calling native function: ", nativeFunc->name);
            return callNativeFunction(nativeFunc, arguments);
        }
        catch (const std::bad_cast &)
        {
            DEBUG_LOG("Failed to cast to native function wrapper");
            throw std::runtime_error("Can only call functions");
        }
    }

    std::string typeName;
    switch (callee.getType())
    {
    case Value::Type::Null:
        typeName = "null";
        break;
    case Value::Type::Boolean:
        typeName = "boolean";
        break;
    case Value::Type::Integer:
        typeName = "integer";
        break;
    case Value::Type::Float:
        typeName = "float";
        break;
    case Value::Type::String:
        typeName = "string";
        break;
    case Value::Type::Object:
        typeName = "object";
        break;
    case Value::Type::Function:
        typeName = "function";
        break;
    case Value::Type::Class:
        typeName = "class";
        break;
    default:
        typeName = "unknown";
        break;
    }
    throw std::runtime_error("Can only call functions or constructors, got: " + typeName);
}

Value Interpreter::evaluateAssignmentExpression(AssignmentExpressionNode *node)
{
    Value rhs = evaluate(node->right.get());

    if (auto varExpr = dynamic_cast<VariableExpressionNode *>(node->left.get()))
    {
        // Simple variable assignment
        if (node->op == "=")
        {
            environment->assign(varExpr->name, rhs);
            return rhs;
        }

        // Compound assignment (+=, -=, etc.)
        Value lhs = environment->get(varExpr->name);

        if (node->op == "+=")
            environment->assign(varExpr->name, lhs + rhs);
        else if (node->op == "-=")
            environment->assign(varExpr->name, lhs - rhs);
        else if (node->op == "*=")
            environment->assign(varExpr->name, lhs * rhs);
        else if (node->op == "/=")
            environment->assign(varExpr->name, lhs / rhs);
        else if (node->op == "%=")
        {
            Value result = Value(lhs.asInt() % rhs.asInt());
            environment->assign(varExpr->name, result);
        }
        else
            throw std::runtime_error("Unknown assignment operator: " + node->op);

        return environment->get(varExpr->name);
    }
    else if (auto memberExpr = dynamic_cast<MemberAccessExpressionNode *>(node->left.get()))
    {
        // Object property assignment
        Value object = evaluate(memberExpr->object.get());

        if (!object.isObject())
        {
            throw std::runtime_error("Cannot set property on non-object value");
        }

        auto obj = object.asObject<Object>();

        // Handle compound assignment for properties
        if (node->op != "=")
        {
            Value lhs;
            auto it = obj->fields.find(memberExpr->memberName);
            if (it != obj->fields.end())
            {
                lhs = it->second;
            }

            if (node->op == "+=")
                rhs = lhs + rhs;
            else if (node->op == "-=")
                rhs = lhs - rhs;
            else if (node->op == "*=")
                rhs = lhs * rhs;
            else if (node->op == "/=")
                rhs = lhs / rhs;
            else if (node->op == "%=")
                rhs = Value(lhs.asInt() % rhs.asInt());
            else
                throw std::runtime_error("Unknown assignment operator: " + node->op);
        }

        obj->fields[memberExpr->memberName] = rhs;
        return rhs;
    }

    throw std::runtime_error("Invalid assignment target");
}

Value Interpreter::evaluateMemberAccessExpression(MemberAccessExpressionNode *node)
{
    DEBUG_LOG("Evaluating member access: ", node->memberName);

    // Evaluate the object expression directly - no special handling for simple variables
    Value object = evaluate(node->object.get());

    DEBUG_LOG("Member access on object of type: ", static_cast<int>(object.getType()),
              ", isObject: ", object.isObject(),
              ", for property: ", node->memberName);

    if (!object.isObject())
    {
        std::string typeName;
        switch (object.getType())
        {
        case Value::Type::Null:
            typeName = "null";
            break;
        case Value::Type::Boolean:
            typeName = "boolean";
            break;
        case Value::Type::Integer:
            typeName = "integer";
            break;
        case Value::Type::Float:
            typeName = "float";
            break;
        case Value::Type::String:
            typeName = "string";
            break;
        case Value::Type::Object:
            typeName = "object";
            break;
        case Value::Type::Function:
            typeName = "function";
            break;
        case Value::Type::Class:
            typeName = "class";
            break;
        default:
            typeName = "unknown";
            break;
        }
        throw std::runtime_error("Cannot access property '" + node->memberName +
                                 "' of non-object value (type: " + typeName + ")");
    }

    auto obj = object.asObject<Object>();
    if (!obj)
    {
        throw std::runtime_error("Failed to cast to Object");
    }

    // Check if the property exists in the object's fields
    auto it = obj->fields.find(node->memberName);
    if (it != obj->fields.end())
    {
        DEBUG_LOG("Found field: ", node->memberName);
        return it->second;
    }

    // Check if the property exists as a method in the class
    if (obj->klass && obj->klass->hasMethod(node->memberName))
    {
        DEBUG_LOG("Found method: ", node->memberName);
        auto method = obj->klass->getMethod(node->memberName);
        // Bind method to this object
        auto boundMethod = std::make_shared<Function>(
            method->declaration,
            method->closure, // Preserve the original closure
            std::static_pointer_cast<void>(obj));
        return Value(std::static_pointer_cast<void>(boundMethod), Value::Type::Function);
    }

    throw std::runtime_error("Undefined property: " + node->memberName);
}
Value Interpreter::evaluateIntegerLiteral(IntegerLiteralNode *node)
{
    return Value(node->value);
}

Value Interpreter::evaluateFloatingPointLiteral(FloatingPointLiteralNode *node)
{
    return Value(node->value);
}

Value Interpreter::evaluateStringLiteral(StringLiteralNode *node)
{
    return Value(node->value);
}

Value Interpreter::evaluateBooleanLiteral(BooleanLiteralNode *node)
{
    return Value(node->value);
}

Value Interpreter::evaluateNullLiteral(NullLiteralNode *node)
{
    return Value(); // Default constructor creates a null value
}

Value Interpreter::callFunction(const std::shared_ptr<Function> &function, const std::vector<Value> &arguments)
{
    if (!function)
    {
        throw std::runtime_error("Invalid function (null)");
    }

    // The function should have the closure environment correctly set during import
    // So we can use it directly without any additional lookup

    // The declaration can be null for imported functions, but we need data
    if (!function->data)
    {
        throw std::runtime_error("Invalid function (no data)");
    }

    // Get the function name for debugging
    std::string funcName = function->data->name;
    std::cout << "Executing function: " << funcName << " with " << arguments.size() << " arguments" << std::endl;

    // Create a new environment for the function execution
    // Use the function's closure as parent environment if available, otherwise use globals
    auto env = std::make_shared<Environment>(function->closure ? function->closure : globals);

    try
    {
        // Get parameter count from our data
        size_t paramCount = function->getParameterCount();

        // Check argument count
        if (arguments.size() != paramCount)
        {
            throw std::runtime_error("Expected " + std::to_string(paramCount) +
                                     " arguments but got " + std::to_string(arguments.size()));
        }

        // Get parameter names safely
        auto paramNames = function->getParameterNames();

        // Bind arguments to parameters using our deep-copied names
        for (size_t i = 0; i < paramCount; i++)
        {
            env->define(paramNames[i], arguments[i]);
        }
    }
    catch (const std::exception &e)
    {
        throw std::runtime_error(std::string("Error handling function parameters: ") + e.what());
    }

    // Set 'this' if the function is a method
    if (function->thisObject)
    {
        env->define("this", Value(function->thisObject, Value::Type::Object));

        // If this is a method call, make object fields accessible as variables
        try
        {
            auto object = std::static_pointer_cast<Object>(function->thisObject);
            if (object && object->klass)
            {
                // Add all object fields to the environment
                for (const auto &field : object->fields)
                {
                    env->define(field.first, field.second);
                }
            }
        }
        catch (const std::exception &e)
        {
            DEBUG_LOG("Error setting up method fields: ", e.what());
        }
    }

    try
    {
        // Simple function execution - both imported and local functions
        // are handled the same way since they both have declarations
        std::string funcName = function->data ? function->data->name : "unknown";
        std::cout << "Executing function: " << funcName << std::endl;

        if (function->declaration && function->declaration->body)
        {
            std::cout << "Using declaration body with " << function->declaration->body->statements.size() << " statements" << std::endl;

            // Direct execution of the function body
            executeBlockStatement(function->declaration->body.get(), env);
        }
        else
        {
            std::cout << "Function body not found: " << funcName << std::endl;
            throw std::runtime_error("Function body not available");
        }
        // If no return statement was executed, return null
        return Value();
    }
    catch (const ReturnException &e)
    {
        // Return the value from the return statement
        return e.getValue();
    }
}

Value Interpreter::callNativeFunction(const std::shared_ptr<NativeFunctionWrapper> &function, const std::vector<Value> &arguments)
{
    // Check argument count if specified
    if (function->paramCount >= 0 && arguments.size() != static_cast<size_t>(function->paramCount))
    {
        throw std::runtime_error("Expected " + std::to_string(function->paramCount) +
                                 " arguments but got " + std::to_string(arguments.size()));
    }

    // Call the native function implementation
    return function->function(arguments);
}

Value Interpreter::createInstance(std::shared_ptr<Class> klass, const std::vector<Value> &arguments)
{
    DEBUG_LOG("Detected class instantiation: ", klass->name);

    // Create a new object instance
    auto object = std::make_shared<Object>(klass);

    // Create a Value for this object right away
    Value objectValue(std::static_pointer_cast<void>(object), Value::Type::Object);

    // For classes without constructors, use field names from class declaration
    if (!klass->constructor)
    {
        // Initialize declared fields with default values
        if (!klass->fieldNames.empty())
        {
            for (const auto &fieldName : klass->fieldNames)
            {
                // Initialize all fields with default values (0)
                object->fields[fieldName] = Value(0);
                DEBUG_LOG("Pre-initialized field '", fieldName, "' with default value");
            }

            // Apply arguments to fields by position
            for (size_t i = 0; i < std::min(arguments.size(), klass->fieldNames.size()); i++)
            {
                object->fields[klass->fieldNames[i]] = arguments[i];
                DEBUG_LOG("Mapped argument ", i, " to field '", klass->fieldNames[i], "'");
            }

            // For any additional arguments that don't match field names
            for (size_t i = klass->fieldNames.size(); i < arguments.size(); i++)
            {
                std::string fieldName = "arg" + std::to_string(i);
                object->fields[fieldName] = arguments[i];
                DEBUG_LOG("Mapped extra argument ", i, " to generic field '", fieldName, "'");
            }
        }
        else
        {
            // Fallback to generic field names if no fields were declared
            for (size_t i = 0; i < arguments.size(); i++)
            {
                std::string fieldName = "arg" + std::to_string(i);
                object->fields[fieldName] = arguments[i];
                DEBUG_LOG("No field names found, mapped argument ", i, " to generic field '", fieldName, "'");
            }
        }
    }

    // First, initialize with parent class constructor if available and this class doesn't
    // have its own constructor
    bool constructorCalled = false;
    bool hasConstructor = klass->constructor != nullptr;

    if (!hasConstructor && klass->parentClass)
    {
        DEBUG_LOG("No constructor in ", klass->name, ", attempting to call parent constructor");
        // Call parent constructor if available
        if (klass->parentClass->constructor)
        {
            auto parentConstructor = klass->parentClass->constructor;
            auto boundConstructor = std::make_shared<Function>(
                parentConstructor->declaration,
                std::static_pointer_cast<void>(object));

            try
            {
                // Call parent constructor
                callFunction(boundConstructor, arguments);
                constructorCalled = true;
                DEBUG_LOG("Parent constructor for class ", klass->parentClass->name, " executed");
            }
            catch (const std::exception &e)
            {
                DEBUG_LOG("Error in parent constructor: ", e.what());
            }
        }
    }

    // For classes with constructors, initialize with default values and then apply constructor logic
    if (klass->constructor)
    {
        auto constructor = klass->constructor;
        auto declaration = constructor->declaration;

        // First identify what parameters the constructor takes
        std::vector<std::string> paramNames;
        for (const auto &param : declaration->parameters)
        {
            paramNames.push_back(param->name);
        }

        // First identify declared field names to initialize properly
        std::vector<std::string> fieldsToInit = klass->fieldNames;

        // First, scan constructor to find class variables (assignments to non-parameter variables)
        std::set<std::string> classVars;
        std::map<std::string, std::string> paramToClassVarMap;

        // Track which parameter corresponds to which field
        std::map<std::string, std::string> paramToFieldMap;

        if (declaration->body)
        {
            // Scan statements in constructor body to find assignments
            for (const auto &stmt : declaration->body->statements)
            {
                if (auto exprStmt = dynamic_cast<ExpressionStatementNode *>(stmt.get()))
                {
                    if (auto assignExpr = dynamic_cast<AssignmentExpressionNode *>(exprStmt->expression.get()))
                    {
                        // Check if left side is a variable that might be a field
                        if (auto leftVar = dynamic_cast<VariableExpressionNode *>(assignExpr->left.get()))
                        {
                            std::string fieldName = leftVar->name;

                            // Check if this variable is in the field list or is a non-parameter
                            bool isField = std::find(klass->fieldNames.begin(), klass->fieldNames.end(), fieldName) != klass->fieldNames.end();

                            bool isParameter = std::find(paramNames.begin(), paramNames.end(), fieldName) != paramNames.end();

                            if (isField || !isParameter)
                            {
                                classVars.insert(fieldName);
                                DEBUG_LOG("Identified class field: ", fieldName);

                                // If right side is a parameter reference, create mapping
                                if (auto rightVar = dynamic_cast<VariableExpressionNode *>(assignExpr->right.get()))
                                {
                                    std::string paramName = rightVar->name;
                                    if (std::find(paramNames.begin(), paramNames.end(), paramName) != paramNames.end())
                                    {
                                        // This is a parameter-to-field assignment
                                        paramToClassVarMap[paramName] = fieldName;
                                        DEBUG_LOG("Found assignment mapping parameter '", paramName,
                                                  "' to field '", fieldName, "'");
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // Initialize all declared fields from class declaration
        for (const auto &fieldName : klass->fieldNames)
        {
            object->fields[fieldName] = Value(0);
            DEBUG_LOG("Pre-initialized field '", fieldName, "' from class declaration");
        }

        // Initialize parameter fields
        for (const auto &paramName : paramNames)
        {
            object->fields[paramName] = Value(0);
            DEBUG_LOG("Pre-initialized parameter '", paramName, "' with default value");
        }

        // Initialize any other detected class variables
        for (const auto &classVar : classVars)
        {
            if (object->fields.find(classVar) == object->fields.end())
            {
                object->fields[classVar] = Value(0);
                DEBUG_LOG("Pre-initialized class variable '", classVar, "' with default value");
            }
        }

        // Now apply the actual argument values to parameters and mapped fields
        for (size_t i = 0; i < declaration->parameters.size() && i < arguments.size(); i++)
        {
            std::string paramName = declaration->parameters[i]->name;
            object->fields[paramName] = arguments[i];
            DEBUG_LOG("Set parameter '", paramName, "' with argument ", i);

            // If this parameter maps to a class field via constructor assignment, assign the argument value there
            auto it = paramToClassVarMap.find(paramName);
            if (it != paramToClassVarMap.end())
            {
                object->fields[it->second] = arguments[i];
                DEBUG_LOG("Mapped parameter ", paramName, " (arg #", i, ") to field ", it->second);
            }
        }

        // Create a function with this bound to the new object
        auto boundConstructor = std::make_shared<Function>(
            constructor->declaration,
            std::static_pointer_cast<void>(object));

        try
        {
            // Call constructor
            callFunction(boundConstructor, arguments);
            constructorCalled = true;
            DEBUG_LOG("Constructor for class ", klass->name, " executed successfully");
        }
        catch (const std::exception &e)
        {
            DEBUG_LOG("Error in constructor for class ", klass->name, ": ", e.what());
            // Continue despite constructor error - object is still created
        }
    }
    else if (!constructorCalled)
    {
        // Legacy approach - look for a method named "constructor"
        if (klass->hasMethod("constructor"))
        {
            auto constructor = klass->getMethod("constructor");

            // Create a function with this bound to the new object
            auto boundConstructor = std::make_shared<Function>(
                constructor->declaration,
                std::static_pointer_cast<void>(object));

            try
            {
                // Call constructor
                callFunction(boundConstructor, arguments);
                constructorCalled = true;
                DEBUG_LOG("Legacy constructor for class ", klass->name, " executed successfully");
            }
            catch (const std::exception &e)
            {
                DEBUG_LOG("Error in legacy constructor for class ", klass->name, ": ", e.what());
                // Continue despite constructor error - object is still created
            }
        }
        else
        {
            DEBUG_LOG("No constructor found for class ", klass->name);
        }
    }
    return objectValue;
}

void Interpreter::defineNativeFunctions()
{
    // Math functions
    auto defineNativeFunc = [this](const std::string &name, int paramCount, NativeFunction func)
    {
        auto wrapper = std::make_shared<NativeFunctionWrapper>(name, paramCount, func);
        environment->define(name, Value(std::static_pointer_cast<void>(wrapper), Value::Type::Function));
    };

    // Math.abs
    defineNativeFunc("abs", 1, [](const std::vector<Value> &args)
                     {
        if (args[0].isInteger()) 
            return Value(std::abs(args[0].asInt()));
        else 
            return Value(std::abs(args[0].asFloat())); });

    // Math.floor
    defineNativeFunc("floor", 1, [](const std::vector<Value> &args)
                     { return Value(static_cast<int>(std::floor(args[0].asFloat()))); });

    // Math.ceil
    defineNativeFunc("ceil", 1, [](const std::vector<Value> &args)
                     { return Value(static_cast<int>(std::ceil(args[0].asFloat()))); });

    // Math.round
    defineNativeFunc("round", 1, [](const std::vector<Value> &args)
                     { return Value(static_cast<int>(std::round(args[0].asFloat()))); });

    // Math.min
    defineNativeFunc("min", 2, [](const std::vector<Value> &args)
                     {
        if (args[0].isInteger() && args[1].isInteger())
            return Value(std::min(args[0].asInt(), args[1].asInt()));
        else
            return Value(std::min(args[0].asFloat(), args[1].asFloat())); });

    // Math.max
    defineNativeFunc("max", 2, [](const std::vector<Value> &args)
                     {
        if (args[0].isInteger() && args[1].isInteger())
            return Value(std::max(args[0].asInt(), args[1].asInt()));
        else
            return Value(std::max(args[0].asFloat(), args[1].asFloat())); });

    // String functions

    // length
    defineNativeFunc("length", 1, [](const std::vector<Value> &args)
                     { return Value(static_cast<int>(args[0].asString().length())); });

    // substr
    defineNativeFunc("substr", 3, [](const std::vector<Value> &args)
                     {
        std::string str = args[0].asString();
        int start = args[1].asInt();
        int length = args[2].asInt();
        
        if (start < 0) start = 0;
        if (start >= static_cast<int>(str.length())) return Value(std::string(""));
        
        return Value(str.substr(start, length)); });

    // Random number generator
    defineNativeFunc("random", 0, [](const std::vector<Value> &args)
                     { return Value(static_cast<float>(rand()) / RAND_MAX); });
}
// executeSwitchStatement is already defined above
